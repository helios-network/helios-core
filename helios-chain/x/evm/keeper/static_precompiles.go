package keeper

import (
	"fmt"
	"maps"
	"slices"

	bankprecompile "helios-core/helios-chain/precompiles/bank"
	"helios-core/helios-chain/precompiles/bech32"
	"helios-core/helios-chain/precompiles/chronos"
	distprecompile "helios-core/helios-chain/precompiles/distribution"
	"helios-core/helios-chain/precompiles/erc20creator"
	govprecompile "helios-core/helios-chain/precompiles/gov"
	"helios-core/helios-chain/precompiles/hyperion"
	ics20precompile "helios-core/helios-chain/precompiles/ics20"
	"helios-core/helios-chain/precompiles/p256"
	stakingprecompile "helios-core/helios-chain/precompiles/staking"
	chronosKeeper "helios-core/helios-chain/x/chronos/keeper"
	erc20Keeper "helios-core/helios-chain/x/erc20/keeper"
	"helios-core/helios-chain/x/evm/core/vm"
	"helios-core/helios-chain/x/evm/types"
	hyperionKeeper "helios-core/helios-chain/x/hyperion/keeper"
	transferkeeper "helios-core/helios-chain/x/ibc/transfer/keeper"
	stakingkeeper "helios-core/helios-chain/x/staking/keeper"

	authzkeeper "github.com/cosmos/cosmos-sdk/x/authz/keeper"
	bankkeeper "github.com/cosmos/cosmos-sdk/x/bank/keeper"
	distributionkeeper "github.com/cosmos/cosmos-sdk/x/distribution/keeper"
	govkeeper "github.com/cosmos/cosmos-sdk/x/gov/keeper"
	channelkeeper "github.com/cosmos/ibc-go/v8/modules/core/04-channel/keeper"
	"github.com/ethereum/go-ethereum/common"
)

const bech32PrecompileBaseGas = 6_000

// AvailableStaticPrecompiles returns the list of all available static precompiled contracts.
// NOTE: this should only be used during initialization of the Keeper.
func NewAvailableStaticPrecompiles(
	stakingKeeper stakingkeeper.Keeper,
	distributionKeeper distributionkeeper.Keeper,
	bankKeeper bankkeeper.Keeper,
	erc20Keeper erc20Keeper.Keeper,
	authzKeeper authzkeeper.Keeper,
	transferKeeper transferkeeper.Keeper,
	channelKeeper channelkeeper.Keeper,
	govKeeper govkeeper.Keeper,
	chronosKeeper chronosKeeper.Keeper,
	hyperionKeeper hyperionKeeper.Keeper,
) map[common.Address]vm.PrecompiledContract {
	// Clone the mapping from the latest EVM fork.
	precompiles := maps.Clone(vm.PrecompiledContractsBerlin)

	// secp256r1 precompile as per EIP-7212
	p256Precompile := &p256.Precompile{}

	bech32Precompile, err := bech32.NewPrecompile(bech32PrecompileBaseGas)
	if err != nil {
		panic(fmt.Errorf("failed to instantiate bech32 precompile: %w", err))
	}

	erc20CreatorPrecompile, err := erc20creator.NewPrecompile(erc20Keeper, bankKeeper)
	if err != nil {
		panic(fmt.Errorf("failed to instantiate erc20Creator precompile: %w", err))
	}

	chronosPrecompile, err := chronos.NewPrecompile(chronosKeeper, authzKeeper)
	if err != nil {
		panic(fmt.Errorf("failed to instantiate chronos precompile: %w", err))
	}

	hyperionPrecompile, err := hyperion.NewPrecompile(hyperionKeeper, authzKeeper, erc20Keeper)
	if err != nil {
		panic(fmt.Errorf("failed to instantiate chronos precompile: %w", err))
	}

	stakingPrecompile, err := stakingprecompile.NewPrecompile(stakingKeeper, authzKeeper, erc20Keeper)
	if err != nil {
		panic(fmt.Errorf("failed to instantiate staking precompile: %w", err))
	}

	distributionPrecompile, err := distprecompile.NewPrecompile(
		distributionKeeper,
		stakingKeeper,
		authzKeeper,
	)
	if err != nil {
		panic(fmt.Errorf("failed to instantiate distribution precompile: %w", err))
	}

	ibcTransferPrecompile, err := ics20precompile.NewPrecompile(
		stakingKeeper,
		transferKeeper,
		channelKeeper,
		authzKeeper,
	)
	if err != nil {
		panic(fmt.Errorf("failed to instantiate ICS20 precompile: %w", err))
	}

	bankPrecompile, err := bankprecompile.NewPrecompile(bankKeeper, erc20Keeper)
	if err != nil {
		panic(fmt.Errorf("failed to instantiate bank precompile: %w", err))
	}

	govPrecompile, err := govprecompile.NewPrecompile(govKeeper, authzKeeper)
	if err != nil {
		panic(fmt.Errorf("failed to instantiate gov precompile: %w", err))
	}

	// Stateless precompiles
	precompiles[bech32Precompile.Address()] = bech32Precompile
	precompiles[erc20CreatorPrecompile.Address()] = erc20CreatorPrecompile
	precompiles[p256Precompile.Address()] = p256Precompile

	// Stateful precompiles
	precompiles[stakingPrecompile.Address()] = stakingPrecompile
	precompiles[distributionPrecompile.Address()] = distributionPrecompile
	precompiles[ibcTransferPrecompile.Address()] = ibcTransferPrecompile
	precompiles[bankPrecompile.Address()] = bankPrecompile
	precompiles[govPrecompile.Address()] = govPrecompile
	precompiles[chronosPrecompile.Address()] = chronosPrecompile
	precompiles[hyperionPrecompile.Address()] = hyperionPrecompile
	return precompiles
}

// WithStaticPrecompiles sets the available static precompiled contracts.
func (k *Keeper) WithStaticPrecompiles(precompiles map[common.Address]vm.PrecompiledContract) *Keeper {
	if k.precompiles != nil {
		panic("available precompiles map already set")
	}

	if len(precompiles) == 0 {
		panic("empty precompiled contract map")
	}

	k.precompiles = precompiles
	return k
}

// GetStaticPrecompileInstance returns the instance of the given static precompile address.
func (k *Keeper) GetStaticPrecompileInstance(params *types.Params, address common.Address) (vm.PrecompiledContract, bool, error) {
	if k.IsAvailableStaticPrecompile(params, address) {
		precompile, found := k.precompiles[address]
		// If the precompile is within params but not found in the precompiles map it means we have memory
		// corruption.
		if !found {
			panic(fmt.Errorf("precompiled contract not stored in memory: %s", address))
		}
		return precompile, true, nil
	}
	return nil, false, nil
}

// IsAvailablePrecompile returns true if the given static precompile address is contained in the
// EVM keeper's available precompiles map.
// This function assumes that the Berlin precompiles cannot be disabled.
func (k Keeper) IsAvailableStaticPrecompile(params *types.Params, address common.Address) bool {
	return slices.Contains(params.ActiveStaticPrecompiles, address.String()) ||
		slices.Contains(vm.PrecompiledAddressesBerlin, address)
}
